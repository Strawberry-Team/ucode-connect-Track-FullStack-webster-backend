# Архітектурні патерни проєкту

Цей документ описує основні архітектурні патерни, що використовуються в проєкті, пояснюючи їхню роль та застосування.

## 1. Багатошарова Архітектура (Layered Architecture)

Проєкт структуровано за принципами багатошарової архітектури, що розділяє застосунок на логічні шари з чіткими обов'язками.

*   **Рівень презентації (Controller):** Обробляє вхідні запити та відповіді, виконує базову валідацію та викликає методи сервісів.
*   **Рівень бізнес-логіки (Service):** Містить основну логіку застосунку, координує операції та використовує рівень доступу до даних.
*   **Рівень доступу до даних (Repository/Prisma):** Взаємодіє безпосередньо з базою даних, надаючи абстракцію для рівня бізнес-логіки.

**Використання:** Забезпечує розділення відповідальності, що робить код більш організованим, легшим для розуміння, підтримки та тестування.

## 2. Патерн "Контролер" (Controller Pattern)

Контролери (`*.controller.ts`) відповідають за обробку HTTP-запитів, визначення маршрутів та взаємодію з клієнтом. Вони діють як точка входу для запитів, делегуючи виконання бізнес-логіки відповідним сервісам.

**Використання:** Визначайте контролер для кожного логічного набору маршрутів (наприклад, `UsersController` для всіх операцій, пов'язаних з користувачами). Контролери мають бути "тонкими", тобто містити мінімум логіки, не пов'язаної з обробкою запиту/відповіді.

## 3. Патерн "Сервіс" (Service Pattern)

Сервіси (`*.service.ts`) містять основну бізнес-логіку застосунку. Вони інкапсулюють складні операції, використовують репозиторії для роботи з даними та можуть взаємодіяти з іншими сервісами.

**Використання:** Реалізуйте основну логіку застосунку в сервісах. Сервіси мають бути незалежними від транспортного рівня (HTTP) і зосереджуватися виключно на бізнес-правилах та операціях.

## 4. Патерн "Репозиторій" (Repository Pattern) / Об'єкт Доступу до Даних (DAO)

Репозиторії (`*.repository.ts`) та Prisma ORM формують рівень доступу до даних. Репозиторії надають методи для виконання CRUD-операцій (Create, Read, Update, Delete) над сутностями, абстрагуючи деталі роботи з Prisma Client.

**Використання:** Використовуйте репозиторій для кожної моделі даних, з якою потрібно взаємодіяти в базі даних. Всі операції з БД мають проходити через відповідні репозиторії.

## 5. Впровадження Залежностей (Dependency Injection - DI)

NestJS використовує DI для керування залежностями між компонентами. Залежності оголошуються в конструкторах класів і автоматично надаються NestJS IoC-контейнером.

**Використання:** Завжди використовуйте DI для отримання екземплярів сервісів, репозиторіїв та інших провайдерів у контролерах, сервісах чи інших провайдерах. Це спрощує тестування та підтримку коду.

## 6. Патерн "Модуль" (Module Pattern)

Застосунок розділено на модулі (`*.module.ts`), які є основними будівельними блоками NestJS. Модуль групує пов'язані компоненти (контролери, сервіси, інші провайдери) та визначає їхні залежності та експорт.

**Використання:** Організовуйте функціональність застосунку за допомогою модулів. Кожен модуль має бути зосереджений на одній логічній області (наприклад, `UsersModule`, `AuthModule`). Використовуйте імпорт/експорт для керування видимістю компонентів між модулями.

## 7. Об'єкти Передачі Даних (Data Transfer Objects - DTOs)

DTOs (`dto/`) - це прості класи або інтерфейси, що використовуються для визначення структури даних, які передаються між шарами або через мережу (наприклад, тіло запиту, параметри URL, відповіді). Вони часто використовуються з декораторами валідації (`class-validator`) та трансформації (`class-transformer`).

**Використання:** Створюйте DTO для всіх вхідних даних (тіла запитів, параметрів запиту, параметрів маршруту) та для форматування вихідних даних API. Це забезпечує чіткі контракти даних та централізовану валідацію.

## 8. Сутності (Entities)

Сутності (`entities/`) представляють структуру доменних об'єктів або об'єктів, що відображають записи бази даних. У цьому проєкті сутності часто відображають моделі Prisma та можуть включати декоратори `class-transformer` для керування серіалізацією.

**Використання:** Використовуйте сутності для представлення даних в межах рівня бізнес-логіки.

## 9. Аспекти та Middleware (Guards, Interceptors, Filters)

NestJS надає спеціальні компоненти (Guards, Interceptors, Filters) для реалізації крос-функціональної логіки, такої як аутентифікація, авторизація, логування, валідація, трансформація відповідей та обробка винятків. Це дозволяє уникнути дублювання коду та централізувати ці аспекти.

**Використання:**
*   **Guards (`guards/`):** Для логіки авторизації (перевірка прав доступу до маршруту або ресурсу).
*   **Interceptors (`core/interceptor/`):** Для перехоплення запитів або відповідей з метою їх трансформації, додавання логіки перед/після виконання обробника маршруту (наприклад, логування часу виконання, трансформація відповіді).
*   **Filters (`core/filters/`):** Для централізованої обробки винятків та форматування відповідей про помилки. 